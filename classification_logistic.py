# -*- coding: utf-8 -*-

"""
@author: Srikanth
"""

import os
import numpy as np
import gzip

from csv import reader, writer
import six
import ast
import matplotlib.pyplot as plt

from sklearn import svm, datasets
from sklearn.metrics import roc_curve, auc
from sklearn.cross_validation import train_test_split
from sklearn.preprocessing import label_binarize
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.cross_validation import train_test_split
from sklearn import metrics
from sklearn.cross_validation import cross_val_score


# Decide read/write mode based on python version
read_mode, write_mode = ('r','w') if six.PY2 else ('rt','wt')

# Decide zip based on python version
if six.PY2:
    from itertools import izip
    zp = izip
else:
    zp = zip


# Set path to your consolidated files
path = '/root/hackathon/'

os.chdir(path)

# File names
ftrain = 'train_consolidation.gz'
ftest = 'test_consolidation.gz'
flabel = 'trainLabels.csv'
fsubmission = 'submission.gz'

print('loading started')

# Lets read labels first as things are not sorted in files

labels = {}

with open(flabel) as f:
    for row in reader(f):
        labels[row[0]] = int(row[1])

print('labels loaded')

# Dimensions for train set

ntrain = 9976
nfeature = 16**2 + 1 + 1# For two_byte_codes, no_que_marks, label
train = np.zeros((ntrain, nfeature), dtype = int)

with gzip.open(ftrain, read_mode) as f:
    next(f)    # Ignoring header

    for t,row in enumerate(reader(f)):
        train[t,:-1] = map(int, row[1:]) if six.PY2 else list(map(int, row[1:]))
	print row[0]
        train[t,-1] = labels[row[0]]
	print t
        if(t+1)%100==0:
            print(t+1, 'records loaded')

print "Before Binarizing labels"
# Binarize the output
print labels.values
labels = label_binarize(labels.values(), classes=[1,2,3,4,5,6,7,8,9])
print labels
n_classes = labels.shape[1]
print "After Binarizing labels"
print labels.shape

# Add additional noisy features
random_state = np.random.RandomState(0)
n_samples, n_features = train.shape

print "Ready for training"
print "n_samples = %s" % n_samples
print "n_features = %s" % n_features

# shuffle and split training and test sets
X_train, X_test, y_train, y_test = train_test_split(train, labels, test_size=.3, random_state=0)

print "After train test split"
print X_train[1]
print X_test[1]
print y_train[1]
print y_test[1]

# Learn to predict each class against the other
classifier = OneVsRestClassifier(LogisticRegression(C=1e1))
print "Created the classifier. Ready to fit."
y_score = classifier.fit(X_train, y_train).predict(X_test)
print "After fitting the data. Ready to plot."
print X_test
print y_score


# Compute ROC curve and ROC area for each class
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(n_classes):
    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_score[:, i])
    print "False Positive rate for class %d is %s" % (i, fpr[i]) 
    print "True Positive rate for class %d is %s" % (i, tpr[i])
    roc_auc[i] = auc(fpr[i], tpr[i])
    print roc_auc[i]

# Compute micro-average ROC curve and ROC area
fpr["micro"], tpr["micro"], _ = roc_curve(y_test.ravel(), y_score.ravel())
roc_auc["micro"] = auc(fpr["micro"], tpr["micro"])
print roc_auc["micro"]


# Dimensions for train set
ntest = 10873
nfeature = 16**2 + 1 # For two_byte_codes, no_que_marks

test = np.zeros((ntest, nfeature), dtype = int)

Ids = []    # Required test set ids

with gzip.open(ftest, read_mode) as f:
    next(f)    # Ignoring header
    for t,row in enumerate(reader(f)):
        test[t,:] = map(int, row[1:]) if six.PY2 else list(map(int, row[1:]))
        Ids.append(row[0])
        if(t+1)%1000==0:
            print(t+1, 'records loaded')

print('test set loaded')

# Predict for whole test set
print 'Fit for the entire training set'
print train[:,-1].shape
#y_pred = classifier.fit(train[:,:-1], train[:,-1]).predict_proba(test)
y_pred = classifier.fit(train[:,:-1], labels).predict_proba(test)
print 'Done with prediction. Time for results'
print y_pred.shape
print y_pred

# Writing results to file
with gzip.open(fsubmission, write_mode) as f:
    fw = writer(f)
    # Header preparation
    header = ['Id'] + ['Prediction'+str(i) for i in range(1,10)]
    fw.writerow(header)
    for t, (Id, pred) in enumerate(zp(Ids, y_pred.tolist())):
	print type(pred)
        fw.writerow([Id]+pred)
        if(t+1)%1000==0:
            print(t+1, 'prediction written')


# Plot of a ROC curve for a specific class
#plt.figure()
#plt.plot(fpr[2], tpr[2], label='ROC curve (area = %0.2f)' % roc_auc[2])
#plt.plot([0, 1], [0, 1], 'k--')
#plt.xlim([0.0, 1.0])
#plt.ylim([0.0, 1.05])
#plt.xlabel('False Positive Rate')
#plt.ylabel('True Positive Rate')
#plt.title('Receiver operating characteristic example')
#plt.legend(loc="lower right")
#plt.show()

# Plot ROC curve
#plt.figure()
#plt.plot(fpr["micro"], tpr["micro"],
#         label='micro-average ROC curve (area = {0:0.2f})'
#               ''.format(roc_auc["micro"]))
#for i in range(n_classes):
#    plt.plot(fpr[i], tpr[i], label='ROC curve of class {0} (area = {1:0.2f})'
#                                   ''.format(i, roc_auc[i]))

